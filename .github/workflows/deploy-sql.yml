name: Deploy SQL to Azure

on:
  push:
    branches:
      - dev  # Dev auto-deploy
    tags:
      - 'v*' # Prod only on version tags like v1.0.0

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      RG: rg-cellcore-dev
      MIGRATIONS_DIR: db/migrations
      SEED_DIR: db/seed
      VIEWS_DIR: db/views
      POSTVIEW_DIR: db/postview
      POSTSEED_DIR: db/postseed

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with: 
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check SQL server public access
        shell: bash
        run: |
          SERVER_FQDN="${{ secrets.AZURE_SQL_SERVER_DEV }}"
          SERVER="${SERVER_FQDN%%.database.windows.net}"
          az sql server show -g "$RG" -n "$SERVER" --query publicNetworkAccess -o tsv

      - name: Open temp firewall for runner IP
        shell: bash
        run: |
          # Derive short server name from FQDN in secrets
          SERVER_FQDN="${{ secrets.AZURE_SQL_SERVER_DEV }}"
          SERVER="${SERVER_FQDN%%.database.windows.net}"
          RUNNER_IP=$(curl -4 -s https://api.ipify.org)
          RULE="gh-runner-${RUNNER_IP//./-}"
          echo "SERVER=$SERVER" >> $GITHUB_ENV
          echo "RUNNER_IP=$RUNNER_IP" >> $GITHUB_ENV
          echo "RULE=$RULE" >> $GITHUB_ENV
          echo "Opening firewall rule '$RULE' for $RUNNER_IP on server $SERVER in RG $RG"
          az sql server firewall-rule create -g "$RG" -s "$SERVER" -n "$RULE" \
            --start-ip-address "$RUNNER_IP" --end-ip-address "$RUNNER_IP"
          echo "Current firewall rules:"
          az sql server firewall-rule list -g "$RG" -s "$SERVER" -o table


      - name: Install sqlcmd (mssql-tools18)
        shell: bash
        run: |
          set -euo pipefail
          sudo mkdir -p /usr/share/keyrings
          curl -fsSL https://packages.microsoft.com/keys/microsoft.asc \
            | sudo gpg --dearmor --yes -o /usr/share/keyrings/microsoft-prod.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft-prod.gpg] https://packages.microsoft.com/ubuntu/24.04/prod noble main" \
            | sudo tee /etc/apt/sources.list.d/microsoft-prod.list > /dev/null
          sudo apt-get update
          sudo ACCEPT_EULA=Y apt-get install -y mssql-tools18 unixodbc-dev
          echo "/opt/mssql-tools18/bin" >> "$GITHUB_PATH"

      - name: Set environment (DEV vs PROD)
        shell: bash
        run: |
            set -e
            BRANCH="${GITHUB_REF_NAME}"
            if [[ "$BRANCH" == "dev" ]]; then
              echo "Deploying to DEV ..."
              echo "DB_SERVER=${{ secrets.AZURE_SQL_SERVER_DEV }}"    >> $GITHUB_ENV
              echo "DB_NAME=${{ secrets.AZURE_SQL_DATABASE_DEV }}"   >> $GITHUB_ENV
              echo "IS_DEV=true" >> $GITHUB_ENV
            else
              echo "Deploying to PROD ..."
              echo "DB_SERVER=${{ secrets.AZURE_SQL_SERVER_PROD }}"  >> $GITHUB_ENV
              echo "DB_NAME=${{ secrets.AZURE_SQL_DATABASE_PROD }}" >> $GITHUB_ENV
              echo "IS_DEV=false" >> $GITHUB_ENV
            fi

      - name: Acquire AAD token for Azure SQL (for sqlcmd -G)
        shell: bash
        run: |
          set -e
          # Get raw JWT access token for Azure SQL
          TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv)

          # Optional: keep in env if you still want the length check step
          echo "SQLCMDACCESS_TOKEN=$TOKEN" >> $GITHUB_ENV

          # Write token to UTF-16LE file for sqlcmd (-G -P <file>)
          TOKEN_FILE=/tmp/sqltoken
          printf '%s' "$TOKEN" | iconv -f ascii -t UTF-16LE > "$TOKEN_FILE"

          echo "TOKEN_FILE=$TOKEN_FILE" >> $GITHUB_ENV


      - name: DNS & TCP probe
        shell: bash
        run: |
          echo "DB_SERVER=$DB_SERVER"
          getent hosts "$DB_SERVER" || true
          timeout 5 bash -lc 'cat </dev/null >/dev/tcp/'"$DB_SERVER"'/1433' \
            && echo "TCP 1433 reachable" || echo "TCP 1433 NOT reachable"

      - name: Verify sqlcmd + token presence
        shell: bash
        env:
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: |
          sqlcmd -? | head -n 3
          echo "Token length: ${#SQLCMDACCESS_TOKEN}"
          test ${#SQLCMDACCESS_TOKEN} -gt 1000 && echo "Token looks sane." || (echo "Token looks SHORT/empty"; exit 1)

      - name: Smoke test connection
        shell: bash
        env:
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: |
          sqlcmd \
            -S "tcp:$DB_SERVER,1433" \
            -d "$DB_NAME" \
            -G \
            -P "$TOKEN_FILE" \
            -C \
            -l 30 \
            -b \
            -Q "SELECT SUSER_SNAME(); SELECT DB_NAME();"
      
      - name: Define run_folder function
        shell: bash
        run: |
            cat <<'EOF' > /tmp/run_folder.sh
            #!/usr/bin/env bash
            set -euo pipefail

            FOLDER="$1"
            if [[ ! -d "$FOLDER" ]]; then
              echo "[INFO] $FOLDER does not exist; skipping."
              exit 0
            fi

            shopt -s nullglob
            files=( "$FOLDER"/*.sql )
            if (( ${#files[@]} == 0)); then
              echo "[INFO] No .sql files in $FOLDER; skipping."
              exit 0
            fi

            IFS=$'\n' files=($(printf '%s\n' "${files[@]}" | sort))
            for f in "${files[@]}"; do
              base="$(basename "$f")"
              
              if [[ "$base" == "31_seed_group_area_rights.sql" ]]; then
                echo "[INFO] Skipping special param script $base (handled in separate step)."
                continue
              fi

              echo "==> Applying: $f"
              sqlcmd \
                -S "tcp:$DB_SERVER,1433" \
                -d "$DB_NAME" \
                -G \
                -P "$TOKEN_FILE" \
                -C \
                -l 60 \
                -b \
                -I \
                -i "$f"
            done
            EOF
            chmod +x /tmp/run_folder.sh

      - name: Apply migrations
        shell: bash
        env: 
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: /tmp/run_folder.sh "$MIGRATIONS_DIR"

      - name: Apply seeds (DEV only)
        if: env.IS_DEV == 'true'
        shell: bash
        env: 
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: /tmp/run_folder.sh "$SEED_DIR"

      - name: Load group OIDs from secrets
        shell: bash
        run: |
          echo "PROD_READ_OID=${{ secrets.PROD_READ_OID }}"       >> $GITHUB_ENV
          echo "PROD_WRITE_OID=${{ secrets.PROD_WRITE_OID }}"     >> $GITHUB_ENV
          echo "LOG_READ_OID=${{ secrets.LOG_READ_OID }}"         >> $GITHUB_ENV
          echo "LOG_WRITE_OID=${{ secrets.LOG_WRITE_OID }}"       >> $GITHUB_ENV
          echo "QM_READ_OID=${{ secrets.QM_READ_OID }}"           >> $GITHUB_ENV
          echo "QM_WRITE_OID=${{ secrets.QM_WRITE_OID }}"         >> $GITHUB_ENV
          echo "SALES_READ_OID=${{ secrets.SALES_READ_OID }}"     >> $GITHUB_ENV
          echo "SALES_WRITE_OID=${{ secrets.SALES_WRITE_OID }}"   >> $GITHUB_ENV
          echo "GLOBAL_ADMIN_OID=${{ secrets.GLOBAL_ADMIN_OID }}" >> $GITHUB_ENV

      - name: Seed group-area rights (parameterized)
        shell: bash
        env: 
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: |
          sqlcmd -S "tcp:$DB_SERVER,1433" -d "$DB_NAME" -G -P "$TOKEN_FILE" -C -b -I \
            -v PROD_READ_OID="${PROD_READ_OID:-}" \
            -v PROD_WRITE_OID="${PROD_WRITE_OID:-}" \
            -v LOG_READ_OID="${LOG_READ_OID:-}" \
            -v LOG_WRITE_OID="${LOG_WRITE_OID:-}" \
            -v QM_READ_OID="${QM_READ_OID:-}" \
            -v QM_WRITE_OID="${QM_WRITE_OID:-}" \
            -v SALES_READ_OID="${SALES_READ_OID:-}" \
            -v SALES_WRITE_OID="${SALES_WRITE_OID:-}" \
            -v GLOBAL_ADMIN_OID="${GLOBAL_ADMIN_OID:-}" \
            -i db/seed/31_seed_group_area_rights.sql

      - name: Apply views (CREATE OR ALTER)
        shell: bash
        env: 
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: /tmp/run_folder.sh "$VIEWS_DIR"
      
      - name: Check ETL prerequisites for postview
        id: check_etl
        shell: bash
        run: |
          set -e

          READY=$(
            sqlcmd \
              -S "tcp:$DB_SERVER,1433" \
              -d "$DB_NAME" \
              -G \
              -P "$TOKEN_FILE" \
              -C \
              -h -1 -W \
              -Q "SET NOCOUNT ON;
                  IF EXISTS (
                    SELECT 1
                    FROM sys.tables t
                    JOIN sys.schemas s ON t.schema_id = s.schema_id
                    WHERE t.name = 'stg_excel_data'
                      AND s.name = 'dbo'
                  )
                    SELECT 1
                  ELSE
                    SELECT 0;" \
            | tr -d '\r'
          )

          echo "ETL_READY=$READY"
          if [[ "$READY" == "1" ]]; then
            echo "ready=true" >> "$GITHUB_OUTPUT"
          else
            echo "ready=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Apply postview (optional)
        if: steps.check_etl.outputs.ready == 'true'
        shell: bash
        run: /tmp/run_folder.sh "$POSTVIEW_DIR"

      - name: Apply postseed (idempotent)
        shell: bash
        env: 
          SQLCMDACCESS_TOKEN: ${{ env.SQLCMDACCESS_TOKEN }}
        run: /tmp/run_folder.sh "$POSTSEED_DIR"

      - name: Close temp firewall hole
        if: always()
        shell: bash
        run: |
          if [[ -n "${RULE:-}" && -n "${SERVER:-}" ]]; then
            echo "Closing firewall rule '$RULE' on $SERVER in RG $RG"
            az sql server firewall-rule delete -g "$RG" -s "$SERVER" -n "$RULE" || true
          else
            echo "[INFO] Firewall env vars missing; nothing to clean up."
          fi
